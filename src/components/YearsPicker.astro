---
const finalLabel = "10+";

// Ajustes finos
const fontSize = "1.5rem";     // similar a text-2xl
const lineH = "1.2";           // compacto
const boxH = "1.9rem";         // alto REAL del “casillero”
const boxW = "3.2rem";         // ancho del “casillero”

// animación
const spinMs = 2600;           // tiempo de ruleta (subí a 3500 si querés más lento)
const settleMs = 900;          // acomodado final
---

<span
  class="yp inline-flex align-middle"
  style={`--yp-h:${boxH}; --yp-w:${boxW}; --yp-fs:${fontSize}; --yp-lh:${lineH};`}
  aria-label={`Más de 10 años`}
>
  <span class="yp__box">
    <span class="yp__track" data-final={finalLabel}></span>
  </span>
</span>

<script is:inline>
  const root = document.currentScript.previousElementSibling;
  const track = root.querySelector(".yp__track");

  const finalLabel = track.dataset.final || "10+";

  // armamos una lista larga (ruleta) con números pseudo-random y al final 10+
  const pool = Array.from({ length: 11 }, (_, i) => String(i)); // 0..10
  const spins = 22; // cantidad de “saltos” visuales (más = más largo)
  const seq = [];

  for (let i = 0; i < spins; i++) {
    // evitamos meter 10+ muy temprano
    const v = pool[Math.floor(Math.random() * pool.length)];
    seq.push(v);
  }
  seq.push(finalLabel);

  // render
  track.innerHTML = seq.map(v => `<span class="yp__item">${v}</span>`).join("");

  // animación: translateY del track dentro de una máscara (1 línea)
  const box = root.querySelector(".yp__box");
  const boxH = box.getBoundingClientRect().height;

  // Posición final: último item visible
  const finalY = -boxH * (seq.length - 1);

  // timing
  const spinMs = 2600;
  const settleMs = 900;

  // 1) fase ruleta: pasos con easing (parece cupertino sin ocupar alto)
  const t0 = performance.now();
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  // hacemos que llegue cerca del final, pero no clavado
  const nearY = finalY + boxH * 1.5; // queda “cerca” del final

  function spin(now){
    const p = Math.min(1, (now - t0) / spinMs);
    const y = nearY * easeOutCubic(p);
    track.style.transform = `translateY(${y}px)`;
    if (p < 1) requestAnimationFrame(spin);
    else settle();
  }

  // 2) fase settle: cae suave al final
  function settle(){
    track.style.transition = `transform ${settleMs}ms cubic-bezier(.16,1,.3,1)`;
    track.style.transform = `translateY(${finalY}px)`;

    // limpieza de transition (por si se re-renderiza)
    setTimeout(() => { track.style.transition = ""; }, settleMs + 50);
  }

  requestAnimationFrame(spin);
</script>

<style>
  .yp__box{
    display:inline-block;
    width: var(--yp-w);
    height: var(--yp-h);
    overflow:hidden;
    border-radius: .6rem;
    border: 1px solid rgba(226,232,240,.9);
    background: rgba(255,255,255,.85);
    vertical-align: middle;
  }

  .yp__track{
    display:block;
    will-change: transform;
  }

  .yp__item{
    display:flex;
    align-items:center;
    justify-content:center;
    height: var(--yp-h);
    font-size: var(--yp-fs);
    line-height: var(--yp-lh);
    font-weight: 800;
    color: #2F5D50;
  }
</style>